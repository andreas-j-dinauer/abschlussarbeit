\documentclass[10pt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage[a4paper, total={150mm, 237mm}]{geometry}
\usepackage{fontspec}
\setmainfont{Arial}

\begin{document}

%\renewcommand\thesection{\ifnum\value{section}<5\Roman{section}\else\arabic{section}\fi}
\renewcommand\thesection{\Roman{section}}
\pagenumbering{Roman}
\begin{titlepage}
    \begin{center}
        \includegraphics[scale=.3]{dateien/THI_Logo.jpg} \\
        \vspace{0.5cm}
        Technische Hochschule Ingolstadt\\
        \vspace{1cm}
        \normalsize
        Andreas Dinauer\\
        and2925@thi.de\\
        
        \vspace*{0.5cm}
        \LARGE
        \textbf{Erstellung eines Knowledge Graphen aus Jira-Tickets}
            
        \vspace{1cm}
        \normalsize
        Erstprüfer/-in: Prof. Dr. Hans-Michael Windisch \\
        Zweitprüfer/-in: Prof. Dr. Beate Navarro Bullock \\
        \vspace{1cm}
        \normalsize
        Externer Partner: Exentra GmbH
            
    \end{center}
\end{titlepage}

\newpage

\section{Inhaltsverzeichnis}
\newpage
\section{Abkürzungsverzeichnis}
\newpage
\section{Abbildungsverzeichnis}
\newpage
\section{Tabellenverzeichnis}
\newpage
\setcounter{section}{0}
\renewcommand\thesection{\arabic{section}}
\pagenumbering{arabic}
\include{kapitel1}
\section{Anforderungserhebung}
Zunächst müssen die Anforderungen an das System erhoben und kategorisiert werden. Dabei wird zwischen funktionalen und nicht-funktionalen Anforderungen unterschieden. Alle in diesem Kapitel erhobenen Anforderungen sind so gestaltet, dass die Applikation im beliebigem Kontext  und dynamisch eingesetzt werden kann. Den Anforderungen liegt kein spezifischer Anwendungsfall zugrunde.\\
Es gibt vier verschiedene Ansätze zur Erfassung für Anforderungen. Die folgenden Anforderungen wurde größtenteils auf Basis eigener Überlegungen und ersten Code-Ausführungen durch den Ansatz "Kreativität" erhoben. Für eine Beobachtung oder das Untersuchen von Artifakten sind keine Ressourcen wie z.B. Dokumente oder bereits bestehende Anforderungen verfügbar.[978-3-658-37194-4, S.60]
\subsection{Funktionale Anforderungen}
Funktionale Anforderungen beschreiben die fachliche Spezifikation eines Systems, sowie alle Schnittstellen inklusive der Eingangs- sowie Ausgabeparameter des Systems. Diese Anforderungen werden in der Testphase der Entwicklung in Testfälle überführt. Können die Tests erfolgreich ausgeführt werden, so erfüllt die Applikation die zuvor festgelegten Anforderungen.\\
\begin{itemize}
  \item Das System soll genau eine Jira-Cloud Instanz als Datenquelle verwenden. 
  \item Die Interaktion mit der Jira-Cloud API in Java soll mittels der breits von Atlassian bereitgestellten Dependencies umgesetzt werden. Es soll Basic-Authorization verwendet werden. Als Java Build-Tool soll Maven verwendet werden.
  \item Es soll möglich sein, diese Projekte genau zu konfigurieren. Dabei soll es auch möglich sein, für jedes Projekt die zu extrahierenden Vorgangstypen festzulegen. Folgende JSON-Datei gibt unserer Applikation die Anweisung, den Issuetype Task und Bug des Projektes mit dem Schlüssel KAW und den Issuetype Story und Task des Projektes mit dem Schlüssel MUN zu extrahieren und in das Zielsystem zu laden:
    \begin{lstlisting}
    {
        "KAW": ["Task", "Bug"],
        "MUN": ["Story", "Task"]
    }
    \end{lstlisting}
  \item Das System soll alle neuen oder geänderten Objekte periodisch exportieren. Ein Exportvorgang soll einmal pro Tag stattfinden. Ein Exportvorgang soll immer zur gleichen Tageszeit und außerhalb der Zeit geschehen, in welcher mit dem Zielsystem gearbeitet wird.
  \item Das System soll alle relevanten Objekte exportieren, die ein Jira-Projekt umfassend beschreiben. Diese sind z.B. Vorgänge, Vorgangstypen, Projekte und Kommentare.
  \item Das System muss alle Daten auf die Zieldatenbank transformieren. Alle für die Analyse nicht relevanten Metadaten aus dem Jira-System sollen aussortiert werden. Ausschließlich wichtige Felder für die folgende Analysen sollen in ein angemessenes Format transormiert werden.
  \item Die Extraktion eines jeden Objektes soll dokumentiert werden. Hierzu werden alle Vorgänge in einer Datenbank erfasst. Zu jedem Vorgang werden mindestens der Zeitpunkt, der Typ und die Kennung eines Objektes erfasst.
  \item Die Applikation soll Änderungen an Objekten erkennen und diese historisieren, also alle Änderungen in einen zeitlichen Zusammenhang bringen und ordnen können.
  \item Die Zieldatenbank soll für effiziente Analysen geeignet sein und Objekte effizient miteinander verknüpfen.
\end{itemize}
\subsection{Nicht-funktionale Anforderungen}
Nicht-funktionale Anforderungen beschreiben den Aufbau des Systems. Auch sie werden in Form von Testfällen nach Beenden der Entwicklung geprüft und müssen für eine erfolgreiche Entwicklung erfüllt sein.\\
\begin{itemize}
\item Das System soll alle Extraktionsvorgänge in einer Datenbank dokumentieren und falls eine Ausführung nicht stattgefunden hat, dieses erkennen, diese bis zu einem gewissen Zeitpunkt nachholen. Eine Ausführung kann beispielsweise nicht stattfinden, wenn das System zum geplanten Zeitpunkt nicht lauffähig ist. Wird die Applikation später gestartet, soll diese mit der Ausführung beginnen.
\item Das Systen muss weitestgehend fehlerfrei arbeiten. Insbesondere müssen alle vorgesehenen Objekte extrahiert werden. Es darf kein Objekt, welches geändert oder neu erstellt wurde ohne Export im Quellsystem (durch z.B Fehler mit dem Zeitstempel durch Latenzen bei der Anfrage) verbleiben.
\item Das System soll flexibel gestaltet sein und alle notwendigen Parameter zur Extraktion durch Umgebungsvariablen erhalten. Wichtige Parameter sind beispielsweise der Jira Benutzer, dessen Passwort und die URL der Jira Instanz. Ein Pfad zur Konfigurationsdatei aller relevanten Jira-Projekte sowie Vorgangstypen, welche zur Extraktion bestimmt sind, soll auch durch eine Umgebungsvariable gesetzt werden können.
\item Die Applikation soll speziell für containerisierte Umgebungen und Cloudumgebungen bestimmt sein und somit als Image für IaC-Anwendungen (z.B. Docker oder Kubernetes) ausführbar sein.
\item Die Applikation soll nicht skalierbar sein. Es ist nur eine Instanz im Betrieb vorgesehen. Ein Entwurf, um das System als Cluster zu betreiben ist sinnvoll, wird aber aufgrund von übermäßigem Aufwand bei der Implementierung der Kommunikation zwischen Instanzen nicht umgesetzt.
\end{itemize}
\section{Auswahl der Softwarekomponenten}
Im folgenden wird begründet, warum eine bestimmte Technologie ausgewählt wird und wie diese unser System ergänzt und warum diese optimal mit anderen Komponenten integriert werden kann.
\subsubsection{Auswahl eines geeigneten Datenbankmodells}
Der Mehrwert der Applikation für einen Anwender entsteht durch die Auswertung der Daten in unserem Zielsystem. Daher ist es besonders wichtig, auf ein Datenbankmodell zurückzugreifen, welches unseren Anwendungszweck bestmöglich unterstützt.
\subsubsection{Auswahl eines geeigneten Extraktors}
Der Extraktor unseres Systems implementiert den ETL-Prozess und bringt diesen zur Ausführung. Seine Aufgabe ist das extrahieren der Daten, das transformieren der Daten in das Format des Zielsystems sowie das Laden der Daten in das Zielsystem. Implementiert wird dieser in der Programmiersprache Java. Grund hierfür ist, dass Java sehr weit verbreitet und etabliert ist sowie eine große Auswahl Frameworks und Bibliotheken bei der Entwicklung bietet. Zur Unterstützung in der Entwicklung wird ein Framework verwendet. Aus verschiedenen Gründe wird Quarkus eingesetzt. Ein großer Vorteil des Frameworks ist, dass es unter der Apache License 2.0 als Open Source Software eingesetzt werden kann. Außerdem bietet Quarkus eine sehr umfangreiche Auswahl an Erweiterungen für verschiedene Anwendungsfälle und unterstützt durch eine große Auswahl an Funktionen auch die Integration mit anderen Softwarekomponenten und Technologien. Quarkus zeichnet sich durch eine schnelle Startzeit sowie die Optimierung für Container-Technologien und somit Cloud-Umgebungen aus. Ein weiterer Vorteil der Quarkus-Frameworks ist die Implementierung der Jakarta WS RS Schnittstelle.
\subsection{Konzept des Data Warehouses}
Die Architektur unseres Systems ist einem Data Warehouse sehr ähnlich und erfüllt alle Eigenschaften eines Data Warehouses nach Inmon. Diese Erkenntnis unterstützt beim Entwurf des Systems und ermöglich es, Konzepte und Technologien des Data Warehouses einzusetzen.
\begin{itemize}
  \item Historisierung: Alle Objekte des Jira Systems sind mit einem Zeitstempel der letzten Änderung, sowie der Erstellung versehen, was den Aufbau eines historisierten Datenbestandes ermöglicht.
  \item Integriert: Wir extrahieren unsere Daten aus nur einem System. Das Hinzufügen eines weiteren Jira-Systems ist möglich und wird in der Architektur des Systems berücksichtigt.
  \item Nicht-Volatilität: Der Datenbestand wird dauerhaft aufgebaut und bleibt bestehen. In Gegensatz zu operativen Systemen werden aus unserem Zielsystem keine Daten gelöscht.
  \item Fach-orientiert: Unser Datenbestand hält fachliche Daten aus dem operativen Geschäftsablauf.
\end{itemize}
\section{Chancen und Eigenschaften von Graphdatenbanken}
\section{Design und Architektur}
\subsection{Grundlagen des ETL-Prozesses}
Unsere aufzubauende Datenbank kann als Data-Warehouse betrachtet werden und wird demnach mit Hilfe eines ETL-Prozesses aufgebaut und befüllt. Die Datenbank soll immer bestmöglich den Stand des Quellsystems abbilden. Eine Möglichkeit der Datenübernahme in den Knowledge Graphen wäre ein periodisch ablaufender Job, welcher alle Änderungen aus dem Quellsystem identifiziert und extrahiert. Dieser Ablauf wird in unserem Fall möglich sein, da jedes Jira-Ticket standardmäßig ein Feld \glqq Created\grqq\:und \glqq Updated\grqq\:besitzt, welches uns erlaubt, alle neuen Änderungen im System zu erkennen. Der Job lässt sich in zwei Aufgaben unterteilen. Ein Teil davon wird alle neu erstellten Tickets der letzten Periode übernehmen. Der zweite Teil des Jobs wird alle geänderten Tickets der letzten Periode erkennen und die Änderungen extrahieren und übernehmen. Um eine hohe Aktualität des Knowledge Graphen zu gewährleisten ist die Periodendauer möglichst gering zu wählen. \\
\subsection{Duplikaterkennung}
Inkonsistenzen können in unserem System entstehen, wenn ein Jira-Ticket fehlerhafte Daten enthält. Existieren zwei Tickets, welche denselben Sachverhalt beschreibt handelt es sich um ein Duplikat. Beschreiben zwei Tickets den gleichen Sachverhalt sind diese nicht als Duplikat zu werten sondern weisen darauf hin, dass ein Problem möglicherweise öfters auftritt und somit schwerwiegender sein könnte. Wahre Duplikate können zu einem Ticket zusammengeführt werden. Zwei Tickets, die mit einer gewissen Wahrscheinlichkeit den gleichen Sachverhalt beschreiben können entweder bei der Übernehme in das Data Warehouse mittels KI mit einem Ähnlichkeitswert versehen werden oder ohne Ähnlichkeitswert übernommen werden. Im zweiten Fall werden ähnliche oder gleiche Sachverhalten später durch den Chatbot bei Anfragen erkannt. Eine genaue Handhabung von Duplikaten und ähnlichen Tickets wird genauer in der Abschlussarbeit erläutert.\\
Haben sich Informationen im Quellsystem seit der letzten Übernahme geändert, so wird eine neue Version des Tickets angelegt. Eine Änderung lässt sich durch das Feld \glqq Updated\grqq\:bestimmen. Dabei handelt es sich um einen Zeitstempel der letzten Änderung. Welches Feld sich genau geändert hat ist nur durch einen aufwändigeren Abgleich mit der vorherigen Version des Tickets bestimmbar.
\subsection{Auditierung}
\section{Implementierung und Testen}
\subsection{Implementierung der Extraktor-Komponente}
\subsubsection{Extraktion der Daten}
Der Extraktor soll kaskadenartig vorgehen. In einem Jira-Projekt stehen viele Objekttypen mit einer 1:n Kardinalität in Verbindung (z.B Projekt und Issue oder Issue und Kommentar). Der Extraktor beginnt mit dem höchsten Objekt in der Hierarchie also einem Jira Projekt und arbeitet sich schrittweise durch alle Objekttypen. Zunächst werden für ein Jira Projekt alle relevanten Vorgänge ermittelt und extrahiert. Diese Vorgänge wiederum stehen in Beziehung mit weiteren Objekttypen, welche anschließend ebenfalls extrahiert werden. Dabei sind Felder, Kommentare, Anhänge oder die Historie des Vorgangs relevant. Außerdem soll zu jedem Vorgang auch der Vorgangstyp extrahiert werden, welcher meist die Art des Vorgangs beschreibt. Ein Vorgangstyp Bug beispielsweise verdeutlicht, dass dieser Vorgang existiert, um ein bestehendes Problem zu lösen.
\subsubsection{Laden der Daten}
Ein zentrales Problem beim Laden der Daten in unser Zielsystem ist die Erkennung von bereits zuvor extrahierten und geladenen Objekten. Um ein breits in das Zielsystem geladenes Objekt zu identifizieren, kann zunächst ein eindeutiger Schlüssel festgelegt werden. Stimmt dieser Schlüssel mit einem Objekt im Zielsystem überein, wurde dieses Objekt bereits geladen und ein Match wurde gefunden. Außerdem können jedoch Sachverhalte auftreten in welchen ein Schlüssel nicht ausreichend ist, um einen Sachverhalt mittels dem Vergleich einer Zeichenkette zwei Objekte als dasselbe zu identifizieren. In folge dessen ist ein ausführlicher Vergleich verschiedener Attribute der Objekte notwendig. Sind umfangreiche Freitextfelder wie z.B Beschreibungen vorhanden, können diese mittels Künstlicher Intelligenz verglichen werden, um möglicherweise einen Match zu erkennen. Bei einem Jira-Ticket sind können verschiedene Felder, wie z.B der Titel oder die Beschreibung eines Tickets für einen Vergleich herangezogen werden.

\subsubsection{Quellsystem}
\subsubsection{Zielsystem}
\subsection{}
\section{Anhang}
\newpage
\section{Literaturverzeichnis}
Koleoso, T. (2020) Beginning Quarkus Framework: Build Cloud-Native Enterprise Java Applications and Microservices, Berkeley, CA, Apress\\\\
Quarkus (© 2024): What is Quarkus? [Online]. Verfügbar unter https://quarkus.io/about (Abgerufen am 11. November 2024)\\\\
Tremp, H. (2022)  Agile objektorientierte Anforderungsanalyse:  Planen – Ermitteln – Analysieren – Modellieren – Dokumentieren – Prüfen, Wiesbaden, Springer Verlag\\\\
Vaisman, A. und Zimányi, E. (2022) Data Warehouse Systems: Design and Implementation, 2. Aufl., Berlin, Springer Verlag\\\\

\end{document}
